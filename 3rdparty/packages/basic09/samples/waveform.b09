PROCEDURE waveform(* from Musical Applications of Microprocessors by Hal Chamberlin(* (1985, Hayden Books); "Table Filling by Fourier Series", p.432(* This differs from the original street BASIC version:(* 1. BASIC09 has real procedures! We take the harmonics(* as an input parameter, and the waveform is stored(* in an output parameter. Getting the harmonics and(* displaying the result? That's the caller's business.(* 2. The original program puts a trig function call,(* one of the slowest things on microcomputers in the(* book's day, in the innermost loop. With the help(* of a basic trig identity, one can get the same result(* with two tables that can be set *outside* the loops.(* 3. The original code would never use random values(* for the phase. Here, again, it's the caller's job.(* 4. There's no need for a separate loop to get the(* maximum waveform absolute value.TYPE HARMONIC=amplitude,phase:REALTYPE SINCOS=sine,cosine:REALPARAM h(11):HARMONIC; wavetable(256):REALDIM sinTable(256):REAL; htrig(11):SINCOSDIM i,j,ij,cosIndex,sinIndex:INTEGERDIM delta,angle,cosVal,sum,max,scale:REALBASE 0FOR i:=0 TO 10angle:=(PI+PI)*h(i).phasehtrig(i).cosine:=COS(angle)htrig(i).sine:=SIN(angle)NEXT idelta:=(PI+PI)/256.angle:=.0FOR i:=0 TO 255sinTable(i):=SIN(angle)angle:=angle+deltaNEXT i(* calculate waveform...max:=.0FOR i:=0 TO 255sum:=.0ij:=0FOR j:=0 TO 10cosIndex:=LAND(ij+64,255)sinIndex:=LAND(ij,255)cosVal:=sinTable(cosIndex)*htrig(j).cosine-sinTable(sinIndex)*htrig
(j).sinesum:=sum+h(j).amplitude*cosValij:=ij+iNEXT jwavetable(i):=sumsum:=ABS(sum)IF sum>max THEN max:=sumENDIF NEXT i(* ...and normalize it to (-1,1).(* (0.9999 should be 1 - machine epsilon, but BASIC has(* no standard way to get it; 0.9999 will have to do.)scale:=.9999/maxFOR i:=0 TO 255wavetable(i):=wavetable(i)*scaleNEXT iPROCEDURE Program(* A procedure that runs waveform; this and waveform(* collectively do what the programs people have(* posted based on the Chamberlin book program do,(* or will once I have the graphics done. :)(* This separation shows one of the many advantages(* BASIC09 has over "street BASICs" like Color BASIC.(* A street BASIC program is a monolith. It can't be(* broken down into parts; even if you use subroutines,(* they have to know the specific variables containing(* the values they use and where results are expected...(* as well as everything else so they won't overwrite them.(* BASIC09 has procedures with locals and parameters,(* allowing high cohesion and low coupling, properties(* of resuable, quality code.(* Sadly, these procedures show one of BASIC09's issues: array(* bounds must be constant, even for array parameters.(* That makes BASIC09 not as well suited for numerical methods(* that work on arrays of arbitrary size.TYPE HARMONIC=amplitude,phase:REALDIM h(11):HARMONIC; wavetable(256):REALDIM i:INTEGERBASE 0(* AmplitudeDATA .0,.8,.6,.2,.55,1.,.7,.3,.2,.1,.05(* Phase (expressed as a fraction of 2pi)DATA .0,.0,.2,.4,.7,.45,.1,.5,.85,.9,.0PRINT DATE$; " start"FOR i:=0 TO 10READ h(i).amplitudeNEXT iFOR i:=0 TO 10READ h(i).phaseNEXT iRUN waveform(h,wavetable)PRINT DATE$; " finish"RUN plot(wavetable)PROCEDURE plotPARAM wavetable(256):REALDIM i,path:INTEGER; response:STRING[1]BASE 0OPEN #path,"/w":WRITERUN gfx2(path,"DWSET",8,0,0,40,24,0,2,2)RUN gfx2(path,"CUROFF")RUN gfx2(path,"SELECT")RUN gfx2(path,"SETDPTR",0,96-FIX(wavetable(0)*32.))FOR i:=1 TO 255RUN gfx2(path,"LINE",i,96-FIX(wavetable(i)*32.))NEXT iGET #0,responseCLOSE #pathRUN gfx2("SELECT")